'''
ーーー関数の再帰ーーー

＝解説＝
関数knapsack(values, weight, capacity)は、重量制限がcapacity以下という条件のn個のアイテムのナップサック問題を解く。

「重量制限がcapacity以下という条件のアイテムがn個のときの最適解」は、以下のどちらか。

n個目のアイテムが最適解に入らない時の最適解：重量制限がcapacity以下という条件のアイテムがn-1個のときの最適解
n個目のアイテムが最適解に入る時の最適解：「重量制限が『capacity ー n個目の重さ』以下という条件の
アイテムがn-1個のときの最適解」にn個目を加えた時の最適解
すなわち「アイテムn個の最適値」は、「アイテムn - 1個の最適値」と
「『重量制限からn個目の重量を引いて出したアイテムn - 1個の最適値』＋n個目の値」の大きい方になる。

n個目の結果を求めるのにn-1個目の結果を使うので、関数を再帰的に書けます。
再帰を使うときは、終了条件を書く必要があります（書かないと無限に実行しようとして、スタックオーバーフローというエラーになる）。

今回の終了条件は、アイテム数が空の時で、その時の解は0。
また、n-1個までの解は、knapsack(values[:-1], weights[:-1], 重量制限)になるので再帰的に書ける。



＝再帰の様子＝
knapsackを実行すると、最適値が26となります。計算を追ってみる。

4つのアイテムをA, B, C, Dとすると、ADが選択される。
流れを追って確認。

重量制限9で、ABCDから選択。
  重量制限9で、ABCから選択（Dは選択しない）。
    重量制限9で、ABから選択（Cは選択しない）。
      重量制限9で、Aから選択（Bは選択しない）。
        A: 11
      重量制限4で、Aから選択しBを追加（Bは選択する）。
        AB: 24
    重量制限5で、ABから選択しCを追加（Cは選択する）。
      重量制限5で、Aから選択しCを追加（Bは選択しない。
        AC: 23
      重量制限0で、Aから選択しBCを追加（Bは選択する）。
        BC: 25
  重量制限3で、ABCから選択しDを追加（Dは選択する）。
    重量制限3で、ABから選択しDを追加（Cは選択しない）。
      重量制限3で、Aから選択しDを追加（Bは選択しない）。
        AD: 26 ← 最適値
このように、分割された問題を何度も解くことになります。


＝補足＝
AB: 24という記述は、「A, Bを選択し価値の総和が24である」ことを意味している。
「重量制限4で、Aから選択しBを追加」は、「重量制限9で、ABから選択」に対して「Bを必ず選択」する場合の計算になる。
Bは後で追加するので、まず「Bを除いた場合の最適解」を計算する。
そのためBの重量である5を重量制限9から除いて「重量制限4で、Aから選択」する場合を考える。
'''


values = [11, 13, 12, 15]  # アイテムごとの価値
weights = [3, 5, 4, 6]  # アイテムごとの重さ
capacity = 9  # 重量制限

def knapsack(values, weights, capacity):
    if not values:  # 終了条件
        return 0
    # 最後のアイテムを入れない場合
    val = knapsack(values[:-1], weights[:-1], capacity)
    # 最後のアイテムを入れる場合の残りの重量制限
    capacity2 = capacity - weights[-1]
    if capacity2 >= 0:
        res = knapsack(values[:-1], weights[:-1], capacity2)
        val = max(val, res + values[-1])  # 入れる場合
    return val


knapsack(values, weights, capacity)

'''
＝表示＝

２６

'''

